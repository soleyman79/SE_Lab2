# آزمایش دوم: SOLID
## روش TDD
ایجاد این پروژه به کمک روش Test Driven Development یا همان TDD انجام شده است. ابزار مورد استفاده نیز Junit می‌باشد.
## مراحل آزمایش
در ابتدا مطابق تصویر زیر پروژه از remote repository گرفته می‌شود.

![1](https://github.com/soleyman79/SE_Lab2/assets/59166192/e6f5bebd-84b2-4c96-bb17-5edbbf35bef0)

همانطور که در تصویر زیر مشاهده می‌شود، نمونه‌ای از stage کردن تغییرات و کامیت کردن قرار داده شده است:

![2](https://github.com/soleyman79/SE_Lab2/assets/59166192/3aa77d20-8b90-4d4f-ab9d-d382c31d35a4)

در ادامه، چون مطابق دستور کار باید از Test Driven Development استفاده کنیم. بنابراین، ابتدا تست‌ها را می‌نویسیم و چون در ابتدا کدی وجود ندارد، طبیعتا تست‌ها رد می‌شوند و به compile error برخورد می‌کنیم:

![3](https://github.com/soleyman79/SE_Lab2/assets/59166192/e11dd3d4-bddb-4908-a6fe-4d147fd53e5f)

می‌خواهیم در ادامه مسیر، تلاش کنیم که دیگر به compile error برخورد نکنیم و در منطبق کردن کد با تست، یک قدم جلوتر برویم. پس بدنه کلی توابع کلاس مستطیل را بدون پیاده‌سازی قرار می‌دهیم تا صرفا compile error رفع شود:

![4](https://github.com/soleyman79/SE_Lab2/assets/59166192/f7a9723b-a0de-49bd-a8e3-411023bf8b6a)

تصویر زیر نشان می‌دهد با اینکه compile error برطرف شده است، اما به runtime error برخورد کرده‌ایم چون هنوز پیاده‌سازی متد‌ها را انجام نداده‌ایم و صرفا بدنه‌ای از آنها را تعریف کرده‌ایم:

![5](https://github.com/soleyman79/SE_Lab2/assets/59166192/fc04ba64-514b-470c-92fe-149bb68d6729)

در ادامه آزمایش، پیاده‌سازی متدهای کلاس مستطیل را به صورت زیر انجام می‌دهیم:

![6](https://github.com/soleyman79/SE_Lab2/assets/59166192/775869fb-9d6d-4dfa-9ff9-1276d28d6758)

در تصویر زیر، همان طور که مشاهده می‌شود، تست‌ها قبول شده‌اند و مشکلی وجود ندارد:

![7](https://github.com/soleyman79/SE_Lab2/assets/59166192/3bf21fb3-b492-4de2-ab1d-44b60c35cf39)

مجددا نمونه‌ای از stage کردن فایل‌های تغییر یافته و کامیت کردن و پوش‌ کردن آنها به سرور ریموت گیتهاب در تصویر زیر مشهود است:

![8](https://github.com/soleyman79/SE_Lab2/assets/59166192/c86177c1-8cb4-4c19-ba83-7dcc517bc5b4)

در ادامه، می‌خواهیم کلاس مستطیل را تبدیل به کلاسی تغییرپذیر (mutable) کنیم. به این منظور، چون از TDD پیروی می‌کنیم، ابتدا تست‌های متدهای setter و getter را برای طول و عرض مستطیل می‌نویسیم و سپس آنها را تعریف می‌کنیم (بدیهی است که پیش از پیاده‌سازی متد‌ها، تست‌ها رد می‌شوند):

![9](https://github.com/soleyman79/SE_Lab2/assets/59166192/8f7b8837-c108-45d1-92b5-2411e24b2682)

حالا پیاده‌سازی متدها را انجام می‌دهیم:

![10](https://github.com/soleyman79/SE_Lab2/assets/59166192/8e0e451b-5f0f-4293-9fcf-64b12293c419)

همانطور که مشاهده می‌شود، هیچ گونه خطایی از جمله compile error (ناشی از وجود نداشتن پیاده‌سازی متدها) و یا runtime error (ناشی از اشتباه بودن پیاده‌سازی) وجود ندارد:

![11](https://github.com/soleyman79/SE_Lab2/assets/59166192/35ad3c49-a06e-48ba-9b1f-b754ea9247ca)

حالا در قسمت دوم، به سراغ کلاس مربع می‌رویم. مشابه با قسمت قبل، قبل از پیاده‌سازی متدهای این کلاس، تست‌های مربوطه را می‌نویسیم که در همان ابتدا هم رد می‌شوند:

![12](https://github.com/soleyman79/SE_Lab2/assets/59166192/5a049b2e-8dc8-4bd4-a04c-d62ff947087b)

مطابق تصویر زیر، متدها را پیاده‌سازی می‌کنیم:

![13](https://github.com/soleyman79/SE_Lab2/assets/59166192/a28c5881-ce57-43d8-ab10-9e129dae4966)

مشاهده می‌شود که تمامی تست‌ها قبول می‌شوند:

![14](https://github.com/soleyman79/SE_Lab2/assets/59166192/60002853-93e3-49b9-8e70-10f788819a7a)

حالا یک واسط (interface) جدید با نام Shape می‌سازیم که فعلا تنها یک متد محاسبه مساحت calculateArea را دارد. باید تمام اشکال موجود در کد، این واسط را پیاده‌سازی کنند:

![15](https://github.com/soleyman79/SE_Lab2/assets/59166192/0902f2ab-7cdf-49fa-ad59-c9e8903c9049)

مطابق تصویر زیر، کلاس مستطیل را مجبور می‌کنیم که این واسط را پیاده‌سازی کند:

![16](https://github.com/soleyman79/SE_Lab2/assets/59166192/d2563163-40a8-4f67-9480-05dc87796634)

برای مربع هم همین کار را انجام می‌دهیم و کلاس مربع هم این واسط را پیاده‌سازی می‌کند. توجه شود که هر شکل باید این متد را به شیوه خاص و درست خود پیاده‌سازی کند:

![17](https://github.com/soleyman79/SE_Lab2/assets/59166192/2a70213a-2528-4363-970b-b51a8d22f2e5)

مشاهده می‌شود که تمام تست‌ها قبول می‌شوند:

![18](https://github.com/soleyman79/SE_Lab2/assets/59166192/e4d7e4b6-3a23-4192-893b-742798924c06)






## پاسخ پرسش‌ها
+ هر یک از پنج اصل **SOLID** را در دو الی سه خط توضیح دهید.
  + اصل Single Responsibility Principle یا **SRP**
    + هر کلاس باید یک مسئولیت واحد و معین داشته باشد و علت تغییر در آن فقط به یک دلیل مشخص محدود شود. رعایت این اصل باعث افزایش cohesion کلاس‌های موجود در برنامه خواهد شد.
  + اصل Open/Closed Principle یا **OCP**
    + برنامه باید برای توسعه باز و برای تغییر بسته یا اصطلاحا باید open to extension and closed to modification باشد. به این معنی که برای تغییر عملکرد برنامه نیازی به تغییر کد اصلی نباشد. بلکه با افزودن کد جدید یا موردی که با پیش‌فرض‌های موجود سازگاری دارد؛ برنامه تغییر کند.
  + اصل Liskov Substitution Principle یا **LSP**
    + این اصل یک شرط مهم برای رابطه توارث در برنامه‌های مختلف بیان می‌کند. اصل LSP بیان می‌دارد نمونه‌های کلاس‌های فرزند باید بتوانند به عنوان نمونه‌های کلاس پدر مورد استفاده قرار بگیرند. اصطلاحاً گفته می‌شود که childer should not expect more or provied less than their parents.
  + اصل Interface Segregation Principle یا **ISP**
    + واسط‌ها یا همان interface ها نباید به گونه‌ای طراحی شوند که وابستگی به ویژگی‌ها یا عملکردهای لازم را برای کاربرد سازماندهی شده داشته باشند، بلکه باید با استفاده از رابط‌های کوچک‌تر و متمرکزتر، کاربردهای خاص خود را پوشش دهند.
  + اصل Dependency Inversion Principle یا **DIP**
    + وابستگی یا couple بودن عناصر مختلف برنامه باید در سطح interface اتفاق بیفتد؛ و نه در سطح concrete class ها. با رعایت این اصل تغییرات در پشت واسط‌ها متوقف شده و می‌توان DIP را علتی برای OCP دانست.
---
+  اصول SOLID در کدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها، طراحی، پیاده‌سازی، تست و استقرار) استفاده می‌شوند؟ توضیح دهید.
  + این اصول، از جمله اصول طراحی هستند.
---
+  در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار دیرتر از پیاده‌سازی نرم‌افزار انجام می‌شود، اما در روش TDD تست‌نویسی پیش از پیاده‌سازی شروع می‌شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.
  + پیاده‌سازی نرم‌افزار، منطبق بر نیازمندی‌های بحث شده و استخراج شده است و تلاش خود را می‌کند که هدف گفته شده را تحقق ببخشد. چون تست‌ها هم دقیقا به نیازمندی‌ها tracable هستند، دو مورد گفته شده تناقضی با هم ندارند و در هر دو حالت، تضمین می‌کنیم که پیاده‌سازی، منطبق با نیازمندی‌ها است یا نه.
---
+ فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. آیا در این حالت می‌توانستیم مربع را از مستطیل به ارث ببریم؟ توضیح دهید.
  + به طور کلی نمی‌توان مستطیل را در فضای برنامه‌نویسی و نرم‌افزار پدر مربع دانست. زیرا ممکن است در آینده یک نیاز و یا قابلیت مخصوص مستطیل کشف شود. در این صورت کلاس مربع باید آن method را override کرده و خالی کند. بنابراین کلاس فرزند postcondition را تضعیف نموده و اصل LSP نقض می‌شود.
